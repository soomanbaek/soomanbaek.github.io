---
title: 객체지향의 사실과 오해
description: 객체지향이란 무엇인가 그리고 왜 사용하는가를 알 수 있었다.
image: 객체지향의 사실과 오해.png
date: 2023-04-26
---

### [Ch.1] 협력하는 객체들의 공동체

- 객체지향이란 시스템을 상호작용하는 **자율적인 객체들의 공동체**로 바라보고 객체를 이용해 시스템을 분활하는 방법이다.
- 자율적인 객체란 **상태**와 **행위**를 함께 지니며 스스로 자기 자신을 책임지는 객체를 의미한다.
- 객체는 시스템의 행위를 구현하기 위해 다른 객체와 **협력**한다. 각 객체는 협력 내에서 정해진 **역할**을 수행하며 역할은 관련된 **책임**의 집합이다.
- 객체는 다른 객체와 협력하기 위해 메시지를 전송하고, **메시지**를 수신한 객체는 메시지를 처리하는 데 적합한 **메서드**를 자율적으로 선택한다.

> ***객체지향의 핵심은 적절한 책임을 수행하는 역할 간의 유연하고 견고한 협력 관계를 구축하는 것이다.***
>

<H4 style="background-color: #EEE">
💭 내가 알던 객체지향은 재사용성, 상속의 역할을 수행하려고 클래스 생성의 의미로 사용했었는데 ch.1을 읽고나서 지금까지 알던 것은 부수적으로 같이오는 기능일 뿐 객체지향의 본질은 아니구나를 느꼈다.
</H4>

### [Ch.2] 이상한 나라의 객체

객체는 구별가능한 **식별자**, 특징적인 **행동**, 변경 가능한 **상태**를 가진다.

> *행동은 다른 객체로 하여금 간접적으로 객체의 상태를 변경하는 것을 가능하게 한다. 객체는 스스로의 행동에 의해서만 상태가 변경되는 것을 보장함으로써 객체의 자율성을 유지한다.*
>

> ***행동이 상태를 결정한다.** 행동을 결정한 후에 행동에 필요한 정보가 무엇인지를 고려하게 되면 이 과정에서 필요한 상태가 결정된다.*
>

<H4 style="background-color: #EEE">
💭 객체는 스스로의 행동에 의해서만 상태가 변경된다. → `setter`를 사용하는 이유를 알 수 있었다.
평소에 객체에 들어갈 상태를 결정하고 행동을 이후에 결정을 하였는데, 객체지향에서 객체간의 협력을 위해서 행동을 먼저 결정하면 상태는 행동에 의해서 결정이 된다는 것을 알게 되었다.
</H4>

### [Ch.3] 타입과 추상화

**타입**

- 객체의 타입을 결정하는 것은 객체의 **행동**뿐이다.
- 객체가 외부에 제공해야 하는 책임을 먼저 결정하고 그 책임을 수행하는 데 적합한 데이터를 나중에 결정해야 한다.
- 타입은 클래스가 아니다. 클래스는 타입을 구현할 수 있는 방법 중 하나이다.

**추상화**

- 일반화 (공통점을 취하고 차이점을 버림)
- 단순화 (중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거)

> *“현상은 복잡하다. 법칙은 단순하다. 버릴 게 무엇이지 알아내라.”*
>

<H4 style="background-color: #EEE">
💭 지금까지 객체지향적으로 프로그래밍 한다고 생각했는데 아니었다. 이제 객체지향이 어떤 것인지 조금 보이기 시작한다.
객체들을 일반화와 단순화를 통해 추상화를 하고 적합한 타입을 만들자!
</H4>

### [Ch.4] 역할, 책임, 협력

**협력**

> *어떤 협력에 참여하는지가 객체에 필요한 행동을 결정하고, 필요한 행동이 객체의 상태를 결정한다.
개별적인 객체의 행동이나 상태가 아니라 객체들 간의 **협력에 집중하라***
>

**책임**

> *객체지향 설계는 협력에 참여하기 위해 어떤 객체가 어떤 **책임**을 수행해야 하고 어떤 객체로부터 **메시지**를 수신할 것인지를 결정하는 것으로부터 시작된다.*
>

**역할**

> *객체가 **역할**을 대체 가능하기 위해서는 협력 안에서 역할이 수행하는 모든책임을 동일하게 수행할 수 있어야 한다.*
>

**책에서 계속 강조하는 것**

> *객체지향의 핵심은 클래스를 어떻게 구현할 것인가가 아니라 **객체가 협력 안에서 어떤 책임과 역할을 수행할 것인지를 결정하는 것이다.***
>

<H4 style="background-color: #EEE">
💭 지금까지 객체지향으로 구현한다고 했을 때, 클래스에 어떤 데이터와 메서드가 들어가야 할 지에 대해서만 고민하고 작성했었다. 하지만 이 책에서는 객체지향을 설계할 때 객체가 협력 안에서 어떤 책임과 역할을 수행할 것인지를 먼저 결정하고 그 이후에 클래스 구현을 고민해야 한다고 나와있었다. 견문이 넓어지는 느낌이 확실히 든다. 알고 구현하는 것과 모르고 구현하는 것은 천지 차이인거 같다.
+) 책임 주도 설계에 관해서 더 배우고 싶다. 본 책의 저자가 쓴 `오브젝트`라는 책이 있는데 이 책을 다 읽고 한번 읽어보고 싶다.
</H4>

### [Ch.5] 책임과 메시지

> ***적절한 책임**이 **자율적인 객체**를 낳고, 자율적인 객체들이 모여 **유연하고 단순한 협력**을 낳는다.*
>

> *자율적인 책임의 특징은 객체가 ‘어떻게’ 해야 하는가가 아니라 **‘무엇’**을 해야 하는가를 설명한다는 것이다.*
>

> *메시지는 객체로 하여금 자신의 책임, 즉 행동을 수행하게 만드는 유일한 방법이다.*
>

![1](https://user-images.githubusercontent.com/72093196/234914669-ce7d458e-5359-4976-a4f8-089c34f52988.png)

서로 다른 객체들이 `동일한 책임`을 공유한다 = `다형성을 만족`시킨다 = `대체 가능`하다

송신자가 수신자에 대해 매우 작은 정보만 가지고 있더라도 상호협력이 가능하고 다음과 같은 장점이 있다

- 협력이 유연해진다. (수신자가 다른 객체로 바껴도 파급효과 없음)
- 협력이 수행되는 방식을 확장할 수 있다. (협력의 세부적인 수행 방식 수정이 쉬움)

> *객체지향 패러다임으로의 전환은 시스템을 정적인 클래스들의 집합이 아니라 **메시지를 주고받는 동적인 객체들의 집합**으로 바라보는 것에서 시작된다.*
>
- 협력 관계 속에서 다른 객체에게 무엇을 제공해야 하고 다른 객체로부터 무엇을 얻어야 하는가라는 관점에서 접근할 때만 훌륭한 책임을 수행할 수 있다.
    - ⇒ 독립된 객체의 상태와 행위에 대해 고민하지 말고 시스템의 기능을 구현하기 위해 객체가 다른 객체에게 제공하는 메시지에 대해 고민하라.
- 객체가 책임을 완수하기 위해 다른 객체의 도움이 필요하다고 판단되면 도움을 요청하기 위해 어떤 메시지가 필요한지 결정한다.
- 메시지를 결정한 후에는 메시지를 수신하기에 적합한 객체를 선택한다.

![2](https://user-images.githubusercontent.com/72093196/234914694-75634764-8078-4490-ba5e-a792c5fbd7e4.png)

- What/Who 사이클
    - 어떤 행위가 필요한지를 먼저 결정한 후에 이 행위를 수행할 객체를 결정

<H4 style="background-color: #EEE">
💭 저번 장에서 객체지향을 구현하고 있다는 오해를 알았다면 이번 장에서는 어떻게 객체지향을 설계해야 할 지 사실을 알게 되었다.
객체간 협력을 유연하게 하기 위해서는 먼저 어떤 메시지를 보낼 것인지를 고민하고 그 후에 객체를 선택하자!
</H4>

### [Ch.6] 객체 지도

> ***기능이 아니라 구조를 기반으로 모델을 구축하는 편이 좀 더 범용적이고 이해하기 쉬우며 변경에 안정적이라는 것이다.***
>

> ***객체지향은 객체의 구조에 집중하고 기능이 객체의 구조를 따르게 만든다. 시스템 기능은 더 작은 책임으로 분할되고 적절한 객체에게 분배되기 때문에 기능이 변경되더라도 객체 간의 구조는 그대로 유지된다.***
>
- 도메인 모델이란?
    - 소프트웨어가 목적하는 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태
    - 기능을 수용하기 위해 은유할 수 있는 안정적인 구조를 제공한다.
- 유스케이스란?
    - 사용자의 목표를 달성하기 위해 사용자와 시스템 간에 이뤄지는 상호작용의 흐름
    - 사용자에게 제공할 기능을 시스템의 책임으로 보게 함으로써 객체 간의 안정적인 구조에 책임을 분배할 수 있는 출발점을 제공한다.


<H4 style="background-color: #EEE">
💭 이번 챕터에서는 객체지향에 좋은 구조(변경에 유연한 구조)를 짜는 방법을 알 수 있었다.

개발자는 항상 변경에 대비해야 한다. → 변경에 유연하게 대응하려면 `안정적인 구조`가 필요하다. → 안정적인 구조를 만들기 위해 `도메인 모델`을 사용한다. 그리고 `유스케이스`를 통해 객체에 책임을 부여한다. → 이 과정을 통해 `객체 간 협력 관계`를 설계하고 그 후 코드를 짠다.
</H4>

### [Ch.7] 함께 모으기

> ***클래스가 은유하는 개념은 도메인 관점을 반영한다. 클래스의 공용 인터페이스는 명세 관점을 반영한다. 클래스의 속성과 메서드는 구현 관점을 반영한다.***
>

> ***클래스는 위 세가지 관점을 모두 수용할 수 있도록 개념, 인터페이스, 구현을 함께 드러내야 한다. 동시에 코드 안에서 세 가지 관점을 쉽게 식별할 수 있도록 깔끔하게 분리해야 한다.***
>


<H4 style="background-color: #EEE">
💭 도메인 모델로 부터 구현까지 설계하는 과정을 순서대로 볼 수 있던 챕터였다. 전부 과정을 보면서 어떤 느낌인지 어떻게 구현까지 하는지 알 수 있었지만 막상 구현하려면 잘 할 수 있을까란 생각이 든다. 조영호님(저자) 강연 영상을 찾아보면서 좀 더 학습을 해야겠다! 
</H4>